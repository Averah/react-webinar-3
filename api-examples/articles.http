###
# Список товаров

GET http://example.front.ylab.io/api/v1/articles

###
# Список с пагинацией

GET http://example.front.ylab.io/api/v1/articles?limit=10&skip=20

###
# Список с пагинацией и возвратом общего количества (и только нужных свойств через fields)
# Про формат fields смотри http://query.rest

GET http://example.front.ylab.io/api/v1/articles?limit=10&skip=10&
  fields=items(_id, title, price),count

###
# Товар по id

GET http://example.front.ylab.io/api/v1/articles/65817bed5c295a2ff2fcd189

###
# Товар по id с подробностями о стране и категории
# Про формат fields смотри http://query.rest

GET http://example.front.ylab.io/api/v1/articles/65817bed5c295a2ff2fcd189?
  fields=*,madeIn(title,code),category(title)


POST
​/comments


{
  "result": {
    "_id": "string",
    "_type": "string",
    "order": "string",
    "dateCreate": "string",
    "dateUpdate": "string",
    "isDeleted": true,
    "isNew": true,
    "proto": {
      "_id": "string",
      "_type": "string"
    },
    "author": {
      "_id": "string",
      "_type": "string"
    },
    "text": "string",
    "parent": {
      "_id": "string",
      "_type": "string"
    }
  }
}

GET
​/comments

{
  "result": {
    "items": [
      {
        "_id": "string",
        "_type": "string",
        "order": "string",
        "dateCreate": "string",
        "dateUpdate": "string",
        "isDeleted": true,
        "isNew": true,
        "proto": {
          "_id": "string",
          "_type": "string"
        },
        "author": {
          "_id": "string",
          "_type": "string"
        },
        "text": "string",
        "parent": {
          "_id": "string",
          "_type": "string"
        }
      }
    ],
    "count": 0
  }
}

GET
​/comments​/{id}
Выбор одного

{
  "result": {
    "_id": "string",
    "_type": "string",
    "order": "string",
    "dateCreate": "string",
    "dateUpdate": "string",
    "isDeleted": true,
    "isNew": true,
    "proto": {
      "_id": "string",
      "_type": "string"
    },
    "author": {
      "_id": "string",
      "_type": "string"
    },
    "text": "string",
    "parent": {
      "_id": "string",
      "_type": "string"
    }
  }
}


ДЗ №6
Репозиторий: https://github.com/ylabio/react-webinar-3 

В свой ранее созданный форк стянуть ветку lecture-5 и дополнить приложение новой логикой. Сделать новый пул реквест в исходный репозиторий в ветку lecture-5 Прислать ссылку на пул реквест. 

Дизайны в фигме. https://www.figma.com/file/zlt4bp3VfyaSUTf1qbMLn0/YLAB-webinar---TASK5?type=design&node-id=0%3A1&t=QzhP1Ra2i0XTkiRB-1 
Swagger: http://example.front.ylab.io/api/v1/docs/ 

Решение прислать до четверга включительно 21.12.2023 23:59 мск. Доработать и исправить ошибки до понедельника 25.12.2023 13:00

Задача
На странице товара добавить пользовательские комментарии. 

Комментарии отображаются сразу все в виде иерархии. В каждом комментарии имя автора, дата, текст и ссылка для ответа на комментарий.

Ответить или написать новый комментарий может только авторизованный пользователь. Для неавторизованного вывести текст “Войдите, чтобы иметь возможность комментировать”. 

Форма для написания нового комментария показывается в самом низу под всеми комментариями. А форма ответа на комментарий под соответствующем комментарием. Одновременно отображается только одна форма. 

Комментарии выбираются из АПИ, в поле parent указывается id товара, который комментируется, чьи комментарии хотим выбрать.

Для создания нового комментария в parent указывается id товара. Но если создаётся ответ на другой комментарий, то в parent указывается идентификатор комментария, на который отвечаем. 

В качестве внешнего состояния использовать redux. (подготовленный в коде). Всё переписывать на redux не надо.

Дополнительное задание

Логику с мультиязычностью перенести в новый сервис I18n. Функция translate будет методом сервиса. Если ей не передавать в аргументах код языка, то используется текущий код языка в сервисе мультиязычности. Текущий код языка (локаль) тоже должен храниться в сервисе мультиязычности. По сути код языка будет состоянием сервиса. Тем самым отказываемся от использования и store и провайдера для хранения кода языка. Придется изменить интеграцию с компонентами - в хуке useTranslate отслеживать изменение кода языка в сервисе мультиязычности, а не в store/провайдере. В хуке useTranslate доступ к сервису мультиязычности реализуется хуком useServices.

Данные на сервере поддерживают мультиязычность. Если в апи запросах указать код языка заголовком Accept-Languages по стандарту или в X-Lang, то вернуться тексты на указанном языке (есть русский и английский). Необходимо добавить взаимосвязь между сервисом мультиязычности и сервисом АПИ. Непонятно только, либо сервис мультиязычности устанавливает заголовок в сервисе АПИ при смене у себя кода языка. Либо сервис АПИ отслеживает смену языка в сервисе мультиязычности и у себя сам меняет заголовок Accept-Languages. В ответе на задачу объяснить своё решение.